# Teide SQL REPL — Design Document

**Goal:** Drop-in SQL replacement for DuckDB CLI, powered by Teide's C17 engine.
**Scope v0.1:** SELECT, FROM (CSV), WHERE, GROUP BY + aggregates, ORDER BY, LIMIT.

## Architecture

Four crates in a Cargo workspace:

```
teide-cli  (binary: `teide`)     Tokio REPL, readline, output formats
teide-db  (lib)                 sqlparser-rs → Teide DAG planner
teide      (lib)                 Safe Rust wrappers: Context, Table, Graph, Column
teide-sys  (lib, -sys crate)     Raw FFI: bindgen from td.h, static linking
```

Data flow:
```
SQL string
  → sqlparser-rs (DuckDB dialect) → AST
  → Planner validates + resolves names → LogicalPlan
  → Executor maps LogicalPlan → Graph builder calls
  → C engine runs morsel-driven execution
  → Result table returns through FFI
  → REPL formats rows to terminal
```

## teide-sys — FFI Foundation

Raw C bindings generated by `bindgen` from `include/teide/td.h` at build time.

`build.rs` compiles libteide via CMake with `-DTEIDE_PORTABLE=ON` and
`-DCMAKE_BUILD_TYPE=Release`, then statically links `libteide.a` into the
Rust binary. The final `teide` executable is fully self-contained.

## teide — Safe Rust Wrappers

Core types:

| Type | Wraps | Drop |
|------|-------|------|
| `Context` | `*mut td_ctx_t` | `td_ctx_destroy` |
| `Table` | `*mut td_t` | `td_release` |
| `Graph` | `*mut td_graph_t` | graph cleanup |
| `Column` | `i32` (node ID) | — |

All types are `!Send` + `!Sync` (C engine uses thread-local arenas).

`Graph<'a>` borrows its source `Table` via lifetime to prevent use-after-free.

Every FFI call returning `td_t*` is checked with `TD_IS_ERR()` and mapped to
`Result<T, Error>` with variants: `Io`, `Oom`, `Type`, `Parse`.

Builder API:
```rust
let ctx = Context::new();
let df = ctx.read_csv("data.csv")?;
let mut g = Graph::new(&df);
let id1 = g.scan("id1");
let v1  = g.scan("v1");
let grp = g.group_by(&[id1], &[g.sum(v1)]);
let result: Table = g.execute(grp)?;
```

## teide-db — SQL Planner

Uses `sqlparser-rs` with DuckDB dialect.

SQL-to-DAG mappings:

| SQL | teide call |
|-----|-----------|
| `FROM 'file.csv'` | `ctx.read_csv(path)` |
| `SELECT col` | `g.scan("col")` |
| `WHERE expr` | `g.filter(predicate)` |
| `GROUP BY` | `g.group_by(keys, aggs)` |
| `SUM/AVG/MIN/MAX/COUNT` | `g.sum()/g.avg()/...` |
| `ORDER BY` | `g.sort(keys, descs)` |
| `LIMIT n` | `g.limit(n)` |
| `a + b`, `a > 5` | `g.add(a, b)`, `g.gt(a, lit)` |

Name resolution: planner loads CSV first to discover column names/types,
then resolves references. Unknown columns produce clear errors.

Expression trees: recursive AST walk builds nested DAG nodes.

Out of scope for v0.1: JOINs, subqueries, CTEs, window functions,
CREATE TABLE, INSERT, UNION. Returns "not yet supported" error.

## teide-cli — The REPL

Startup modes:
```bash
teide                        # Interactive REPL
teide 'SELECT ...'           # Single query, print, exit
teide -f script.sql          # Execute file
teide data.csv               # REPL with table pre-loaded as 't'
```

REPL loop: `rustyline` editor inside Tokio runtime. Queries run via
`spawn_blocking` so the REPL stays responsive. Ctrl+C cancels running
queries via atomic flag. Ctrl+D exits.

Multi-line: lines without trailing `;` accumulate with `...> ` prompt.

Output formats switchable via dot-commands:
```
.mode table    (default, aligned ASCII)
.mode csv
.mode json
.timer on/off
```

Dependencies: `rustyline`, `tokio`, `comfy-table`, `sqlparser`, `clap`.

## Workspace Layout

```
teide/
├── Cargo.toml                  # workspace
├── crates/
│   ├── teide-sys/
│   │   ├── Cargo.toml
│   │   ├── build.rs            # cmake + bindgen
│   │   └── src/lib.rs
│   ├── teide/
│   │   ├── Cargo.toml
│   │   └── src/lib.rs          # Context, Table, Graph, Column
│   ├── teide-db/
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── planner.rs
│   │       └── expr.rs
│   └── teide-cli/
│       ├── Cargo.toml          # [[bin]] name = "teide"
│       └── src/main.rs
├── include/teide/td.h          # existing C header
├── src/                        # existing C sources
└── CMakeLists.txt              # existing C build
```

`cargo build --release` → `teide-sys/build.rs` compiles C via CMake →
static link → single `teide` binary.

`cargo install teide-cli` from crates.io gives users the `teide` command.
